\begin{tabular}{p{\nodeTextWidthRatio\textwidth}} 
\className{Object}
\\ \hline
\data{oid: objectID}
\desc{every object needs an ID to be tracable in map and in state}
\data{name: string}
\desc{merely a name, irrelevant to the simulation}
\data{shape: Shape}
\desc{which could be empty if the object is an owner}
\data{position: Position}
\desc{position and orientation of an anchor point of the object}
\data{__previous_position: Position}
\desc{to keep the previous state so we can revert}
\data{owner_object: ObjectID}
\data{dependent_objects: dict[ObjectId, Object]}
\data{_latest_intersections: list[IntersectionInstance]}
\data{_infinitesimal_intersection_occured: bool}
\\ \hline
\method{evolve(delta-t) -> list[Object]: offspring-objects}
\desc{changes the state (position, internal attributes, etc) of the object}
\desc{trvial evolution: when the object never changes state}
\desc{offsprings are the possibly non-physical objects required to accomplish something.}

\method{bounding-box() -> Box}
\desc{returns a box which contains the whole object. used to optimize intersection evaluation}

\method{get-required-delta-t()}
\desc{calculates the delta-t it requires to operate. By default 0, meaning no requirement}

\method{time-to-die() -> bool}
\desc{tells the World if it wants to be eliminated. This might be where Agent Smith cheated the matrix!}

\method{add_dependent_object(obj: Object)}

\method{set_intersections(intersections: list[in_in.IntersectionInstance]) -> None}

\method{update_position(new_position)-> None}

\method{revert_position() -> None}

\method{visualize()}
\desc{returns the information required for visualization}

\method{dump_shape_info() - >None}

\method{is_evolvable() -> bool}
\end{tabular} 
